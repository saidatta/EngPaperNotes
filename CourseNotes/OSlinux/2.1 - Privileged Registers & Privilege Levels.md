### 1 ğŸŒ Landscape: Where these concepts sit

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ HW view    â”‚ cores â–¸ registers â–¸ privilege levels â–¸ interrupts        â”‚
â”‚            â”‚                                 â–²                         â”‚
â”‚            â”‚                                 â”‚ â€œhardware â†” softwareâ€   â”‚
â”‚ SW view    â”‚ user â†” C std-lib â†” sys-call â†”  kernel â†” hypervisor        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

> _Goal of this chapter_: understandÂ **how hardware distinguishes â€œwho may touch whatâ€**Â and the control-flow machinery the OS uses to mediate that access.

---

### 2 âš™ï¸ Modern Multicore Chip (recap in one diagram)

```text
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Chip Package â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚ 4â€“64 green â€œcoresâ€ (each has 8-32 HW registers)              â”‚
           â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
           â”‚            Shared multi-level cache hierarchy               â”‚
           â”‚     L1d/L1i  â†’  private  â†˜                                   â”‚
           â”‚     L2        â†’  private   â†˜                                 â”‚
           â”‚     L3/L4     â†’  shared     â†˜                                â”‚
           â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
           â”‚                Off-chip DRAM (â€œmain memoryâ€)                 â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

_Physical address space_Â = set of addresses CPU can emit on the bus (single, flat); can be 48 bits even on 64-bit ISA.

---

### 3 ğŸ“‘ Register Taxonomy

|Class|Visible to user code?|Purpose|Typical x86-64 names|
|---|---|---|---|
|**General-Purpose (GPR)**|âœ…|integer arithmetic, pointers|RAX, RBX, RCXâ€¦|
|**Vector / FP**|âœ…|SIMD & FP math|XMM0-31, YMM0-31|
|**_Privileged_**|âŒ unless CPL = 0|control CPU / devices|CR0â€“CR4, IA32_EFER, DR0-7, MSRs|
|â€¢Â _Hidden_|partly|implicit state (FLAGS)||
|â€¢Â _Control_|no|MMU enable bits, caching, power mgmt||
|â€¢Â _Debug_|no|break-/watch-points||
|â€¢Â _I/O-mapped_|no|talk to devices (e.g., PCI BAR, UART)||

#### 3.1 WhyÂ _extra_Â privileged registers exist

Snapshot problem âœ â€œhang camera from the ceilingâ€ analogy:  
The kernelâ€™s interrupt-prologue needs scratch registersÂ **not clobbered**Â by user context â†’ hardware providesÂ _special_Â save-areas or lets the kernel run with an extended register file.

```assembly
; x86-64 interrupt entry (simplified)
swapgs                 ; get kernel GS base
push   rax â€¦ r15       ; spill user GPRs
mov    rbx, cr3        ; read privileged register (active page-table)
```

---

### 4 ğŸ” Privilege Levels (rings) & CPL

```text
        privilege â†‘
Ring 0  â”€â”€â”€â”€â”€â”€â”€â”€â”   kernel / hypervisor (CPL=0)
Ring 1          â”‚   (mostly unused on x86; used by some micro-kernels)
Ring 2          â”‚
Ring 3  â”€â”€â”€â”€â”€â”€â”€â”€â”˜   user applications (CPL=3)
        privilege â†“
```

_Lower ring number â‡’Â **more**Â privilege._

CPU stores theÂ _Current Privilege Level_Â in segment selector bits (x86) or PC-mode bits (RISC-VÂ `mstatus.mpp`Â etc.).  
TransitionÂ **toward lower privilege**: aÂ _trap_Â (interrupt, exception,Â `syscall`,Â `int n`).  
TransitionÂ **toward higher privilege**:Â `iretq`/`sysret`/`sret`Â âœ hardware verifies target satisfies ring rules.

---

### 5 ğŸ› ï¸ Privileged vs Non-Privileged Instructions

|Attempted from CPL = 3|Hardware response|
|---|---|
|Access CR3|**#GP**Â (General-Protection fault) â†’ kernel kills or emulates|
|`hlt`|#GP (cannot halt)|
|`rdtsc`Â (post-2006 x86)|Allowed â€“ but may be virtualised|
|`mov eax, 0xF4`Â â†’ out to port|#GP or VM-exit (dependent on IOPL & VMX)|
|â€œSilentâ€ polymorphic op (rare)|**dangerous**Â for VMM authors|

> **Trap-and-emulate**Â model: privileged opsÂ _must_Â trap so a hypervisor can virtualise; polymorphic non-trapping ops (historical ISA baggage) are why x86 virtualisation required Intel VT-x/AMD-V hardware assist.

---

### 6 ğŸ“Ÿ Interrupts, Exceptions, System Calls (three entry paths)

```text
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ external event (NIC, keyboardâ€¦) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                 raises *Interrupt*                          â”‚
      â”‚                                                             â–¼
user  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ context save  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
mode                kernel entry (IDT vector)                       â”‚
      â”‚                                                             â”‚
      â”‚           *Exception* (divide-by-0, #PF, #UD)               â”‚
      â”‚                                                             â–¼
      â”‚         *System Call*  (software-raised trap)               â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
```

#### 6.1 Control-flow skeleton (x86-64 Linux)

```assembly
; User wants write(fd, buf, len)
mov    rax, 1        ; SYS_write
mov    rdi, fd
mov    rsi, buf
mov    rdx, len
syscall              ; enters kernel, CPLâ†’0, swaps GS, etc.

; kernel does VFS â†’ driver â†’ device
; return to user
```

#### 6.2 Exception demo - divide-by-zero

```c
int div0(int x) { return x / 0; }
```

CPU detectsÂ `DIV`Â with divisor 0 â†’ raisesÂ `#DE`Â (vector 0). Kernelâ€™sÂ `do_divide_error()`Â kills process with SIGFPE.

#### 6.3 Lazy hardware emulation example

If CPU lacksÂ `sqrtss`, kernel may handleÂ `#UD`Â byÂ **software emulation**Â rather than terminate â‡’Â _exception != fatal_.

---

### 7 ğŸ”„ Context-Switch Anatomy (per CPU)

1. **Interrupt arrives**Â (or scheduler tick).
    
2. SaveÂ _volatile_Â user state (all GPRs, FLAGS, segment bases) on per-CPU stack.
    
3. Update per-task struct:
    
    ```c
    task->rip = regs->rip;
    task->rsp = regs->rsp;
    task->fpu = fpu_state;
    ```
    
4. ChooseÂ `next_task`Â via scheduler (CFS in Linux).
    
5. LoadÂ `CR3`Â ofÂ `next_task`Â â†’ switch address space.
    
6. Restore registers +Â `swapgs`; executeÂ `iretq`Â â†’ back to user at sameÂ `rip`.
    

**Latency targets**: 100 ns (bare metal) to ~1 Âµs (cloud-VM with nested virt).

---

### 8 ğŸ“¤ Signalsâ€ƒ(OS â†’ process callback)

```text
Hardware (IRQ 1: mouse) â”€â–º Kernel ISR â”€â–º input-subsystem
      â””â”€â–º wakes *X11/Wayland server* with SIGIO
                 userland handles paint()
```

_Asynchronous, initiated by kernel after IRQ is serviced._  
Linux keeps pending-signal bitmap insideÂ `task_struct`; delivery happens when returning to user mode.

---

### 9 ğŸ—ï¸ Virtualisation & Rings

|Layer|Typical Ring|Mechanism|
|---|---|---|
|Type-0 hypervisor (Xen bare-metal)|0|Full HW control|
|Service OS / Dom0|1|paravirtual drivers|
|Guest kernels|0Â **inside VM**Â but Ring 1/3 from host PoV|VT-x/AMD-V traps|
|Applications|3|normal|

**Key pain-point**: non-trappingÂ _popf_Â /Â _pushf_Â variants pre-VT-x â†’ â€œring de-privilegingâ€ hacks.

---

### 10 ğŸ”’ Security Insights

- Ring separation blocks direct device access âœ mitigates DMA attacks.
    
- Privileged registers hold secrets (kernel ASLR base, SMEP/SMAP bits).
    
- Spectre/Meltdown forced kernels to flush/segregate some privileged state on mode switch.
    

---

### 11 ğŸ’¡ Study Prompts / Further Reading

|Topic|Why it matters|Pointers|
|---|---|---|
|`sysenter`Â vsÂ `syscall`Â vsÂ `int 0x80`|performance & compatibility|Intel SDM vol 2, LinuxÂ `arch/x86/entry`|
|ARM Exception Levels (EL0-EL3)|compare with x86 rings|ARM ARM D5-3006|
|RISC-V privilege spec (`m`/`s`/`u`Â modes)|clean modern design|RISCV-priv-spec v1.12|
|KVMâ€™s trap-and-emulate loop|real virtualisation code|`virt/kvm/*`Â in Linux|
|Interrupt latency benchmarking (`lat_irq`Â in rt-tests)|measure on your hardware|rt-tests repo|

---

### 12 ğŸ“„ Cheat-Sheet (quick memory cues)

```text
IRQ  = hardware knocks â†’ â€œHey kernel!â€
EXC  = CPU yells â†’ â€œSomething went wrong!â€
SYS  = user whispers â†’ â€œKernel, please do Xâ€
SIG  = kernel taps user â†’ â€œFYI, X happenedâ€
CPL 0|1|2|3 = privilege ring (0 is king)
CR3 = page-table root (switch â‰ˆ context-switch)
```

---

### 13 ğŸ“ Practical Lab Ideas

1. **Patch Linux**Â to log every time a user process triggers #GP.
    
2. **Write bare-metal x86 stub**Â that executesÂ `hlt`Â at CPL = 3, observe fault vector.
    
3. **UseÂ `perf record -e exceptions`**Â while runningÂ `stress-ng --divzero`Â to visualise exception rate.
    
4. **KVM self-VM-exit counter**: instrumentÂ `kvm_exit_reason`Â to measure polymorphic ops frequency.
    

---

_(End of notes â€” drop a ğŸ§ if youâ€™d like deeper dives or diagrams expanded!)_