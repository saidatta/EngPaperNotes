https://www.youtube.com/watch?v=duZOvL31JUE&list=PL1iLu2CSC9EW0VVEBN0XhTMoMVMW4Xd42&index=3
## Table of Contents  
1. [Motivation: A Guaranteed Source of Interrupts](#motivation)  
2. [x86 Privilege Architecture](#privilege)  
   * Rings 0-3 & CPL/IOPL  
   * Privileged **instructions** & **registers**  
3. [Hardware Events ‚Üí OS Entry Points](#events)  
4. [Periodic Timer Interrupts & `jiffies`](#timer)  
   * PIT ‚Üí HPET ‚Üí Local APIC (TSC-deadline)  
   * Cache footprint & ‚Äúapplication‚ÄìOS destructive interference‚Äù  
5. [Evolution of x86 GPRs (8 ‚Üí 16 ‚Üí 32 ‚Üí 64 bit)](#gpr)  
6. [EFLAGS / RFLAGS & the Instruction Pointer](#flags)  
7. [x87 Floating-Point *Register-Stack*](#x87)  
8. [Intel vs AT&T Assembly Syntax](#syntax)  
9. [Virtualisation & Extended Privilege Levels](#virt)  
10. [Key Take-aways & Further Reading](#takeaways)

---
<a name="motivation"></a>
## 1  Motivation: A Guaranteed Source of Interrupts üïí  

| Problem                                                                                   | Consequence                                                                   |
| ----------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **Purely computation-bound program** (no I/O, no page-faults, no syscalls) on *all* cores | OS never regains control ‚áí scheduler can‚Äôt pre-empt ‚áí system appears **hung** |
| Hardware devices misconfigured / disconnected ‚áí no external IRQs                          | Same outcome; OS starved                                                      |

**Solution ‚ñ∂ periodic timer interrupt** generated by an *external* timer chip:  

```

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ motherboard ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  
‚îÇ 8254 PIT | HPET | APIC TMR ‚îÇ ‚Üí IRQ 0 (+ per-CPU local) ‚Üí IDT vector 32  
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

```

* **Jiffy (HZ)** = compile-time constant (#define `HZ`)  
  * Historically 100 Hz (10 ms); modern Linux defaults to **1000 Hz** (1 ms tick).  
* Each tick executes `tick_irq_handler()`, increments the global `volatile unsigned long jiffies`.

> **Exercise‚ÄÇ#1**‚ÄÇRun `cat /proc/timer_list | grep 'tick\|jiffies'` on your kernel ‚â• 6.2.  
> Observe `tick_sched_timer`, per-CPU `hrtimer` mode, and compare actual tick source (TSC-deadline vs HPET).

---
<a name="privilege"></a>
## 2  x86 Privilege Architecture üîí  

### 2.1 Ring Levels & CPL Bits  

```

```
       
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        CR0.PE=1
Ring 0 ‚óÄ‚îÄ‚îÄ‚î§ Kernel ‚îú‚îÄ‚îê CPL=0  
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ  
Ring 1 (rarely used) ‚îÇ  
Ring 2 ‚Äúmiddle-ware‚Äù ‚îÇ  
Ring 3 ‚óÄ‚îÄ‚îÄ‚î§ Userland ‚îú‚îÄ‚îò CPL=3  
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

````

* **CPL (Current Privilege Level)** = lower 2 bits of CS selector.  
* **IOPL (EFLAGS[12:13])** gate for in/out instructions.  
* Segment descriptor **DPL** sets entry permission.

> Modern VT-x/SVM introduces **VMX root / non-root** *below* Ring 0 ‚Äì hardware now distinguishes hypervisor vs guest without stealing Rings 1-2.

### 2.2 Privileged Registers  

| Register | Function | Privileged access |
|----------|----------|-------------------|
| `CR0‚ÄìCR4`, `CR8` | Paging enable, WP, SMEP/SMAP, TSS, IRQ priority | MOV to/from CRn (Ring 0 only) |
| `MSRs` | Model-specific (e.g. `IA32_LSTAR`) | via `rdmsr`/`wrmsr` (Ring 0) |
| `IDTR`, `GDTR`, `LDTR`, `TR` | Descriptor tables | `lidt`, `lgdt`, `ltr` |

```asm
;; Example: switch to kernel page-table (simplified)
mov     rax, [rsp + saved_cr3]
mov     cr3, rax         ; privileged
````

---

## 3 Hardware Events ‚Üí OS Entry Points

|Category|Origin|x86 Gate|Latency budget|
|---|---|---|---|
|**Interrupt**|External device (NIC, disk, timer)|Interrupt Gate|sub-¬µs|
|**Exception**|CPU detected fault (page-fault, div0)|Trap/Fault Gate|ns|
|**System-call**|Program executes¬†`int 0x80`,¬†`syscall`|Syscall entry|<50 ns|

ASCII timing diagram (single CPU):

```
User code                    Kernel ISR       Scheduler
‚îÇ                            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ compute ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄIRQ‚îÄ‚îÄ‚ñ∂‚îÇ save  ‚îÇ‚îÄ‚Üí resched? ‚Üí context_switch()
‚îÇ                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 4 Periodic Timer Interrupts &¬†`jiffies`

### 4.1 Linux implementation (‚â• 6.x)

```c
/* include/linux/jiffies.h */
extern unsigned long volatile jiffies;

/* arch/x86/kernel/time.c */
static irqreturn_t timer_interrupt(int irq, void *dev_id)
{
    tick_handle_periodic(irq);
    return IRQ_HANDLED;
}
```

- `CONFIG_HZ=1000`¬†‚áí¬†`jiffies`¬†increments every 1 ms.
    
- Boot parameter¬†`nohz=on`¬†switches to¬†**tickless-idle**; watchdog still arms one-shot hrtimers when CPU sleeps.
    

#### Cache Interference

```
                         L1d
User data ‚îÄ‚îê          ‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ evicted ‚óÄ‚îÇ  OS   ‚îÇ  ‚Üê ISR code (‚âà hundreds of bytes)
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Minimising ‚Äúfootprint‚Äù ‚áí Linux splits ISR into¬†**top-half**¬†(fast; in IRQ ctx) &¬†**bottom-half**¬†(`tasklet`/`softirq`) executed later.

---

## 5 Evolution of General-Purpose Registers üìà

|ISA width|Register aliases|Count|
|---|---|---|
|**8-bit**|`AL, AH, BL‚Ä¶`|4|
|**16-bit**|`AX, BX, SI, DI, SP, BP`|8|
|**32-bit**|`EAX ‚Ä¶ EDI`|8 (widened)|
|**64-bit**|`RAX ‚Ä¶ R15`|16 (8 legacy + 8 new)|

```
          63            31            15            0
RAX ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ             ‚îÇ             ‚îÇ             ‚îÇ
        [EAX]         [AX]          AH  AL
```

> **Mnemonic:**¬†A‚ÜíAX‚ÜíEAX‚Üí**RAX**¬†(Add an¬†_E_xtension, then¬†_R_egister).

---

## 6 EFLAGS / RFLAGS & Instruction Pointer üó∫Ô∏è

- Size variants: 16-bit¬†**FLAGS**, 32-bit¬†**EFLAGS**, 64-bit¬†**RFLAGS**.
    
- Key arithmetic flags:
    

|Bit|Name|Set when‚Ä¶|
|---|---|---|
|11|OF|signed overflow|
|0|CF|carry/borrow|
|6|ZF|result == 0|
|7|SF|result MSB = 1 (negative)|

Example ‚Äî implement¬†`if (a == b)`¬†in assembly:

```asm
cmp     rdi, rsi      ; a ‚Äì b              ‚Üí ZF
je      .equal_branch ; jumps when ZF=1
```

---

## 7 x87 Floating-Point¬†_Register-Stack_¬†üßÆ

```
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ top (st0)
push ‚îÇ  st0  ‚Üê new
     ‚îÇ  st1
     ‚îÇ  st2
     ‚îÇ  st3
     ‚îÇ  st4
     ‚îÇ  st5
pop  ‚îÇ  st6
     ‚îÇ  st7
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ bottom
```

- **8 √ó 80-bit**¬†registers (extended precision).
    
- Typical instruction pattern:¬†`FADD`¬†implicitly pops operands¬†`st0, st1`, pushes result.
    

```asm
fld     qword [val1]   ; st0 = val1
fld     qword [val2]   ; st0 = val2, st1 = val1
faddp   st1, st0       ; st1 = st1 + st0, pop ‚Üí st0 (result)
fstp    qword [res]
```

_Historical context_: prior to 486DX, the FPU was an external¬†**8087/80387**¬†co-processor; a stack abstraction minimised opcode size and bus traffic.

---

## 8 Intel vs AT&T Assembly Syntax ‚öîÔ∏è

|Attribute|**Intel**¬†(NASM/YASM)|**AT&T**¬†(GAS, Linux kernel default)|
|---|---|---|
|Operand order|`add eax, ebx`¬†(dest, src)|`addl %ebx, %eax`¬†(src, dest)|
|Register prefix|none (`eax`)|`%`¬†(`%eax`)|
|Immediate prefix|none (`10`)|`$10`|
|Memory addr|`[esp+4]`|`4(%esp)`|
|Opcode suffix|size implicit|`b/w/l/q`¬†(`addl`)|

Conversion cheat-sheet:

```text
Intel         AT&T
-----         -----
mov eax, [m]  movl m(%rip), %eax     ; position-indep w/ RIP-rel
push ebp      pushq %rbp
```

---

## 9 Virtualisation & Extended Privilege Levels ‚òÅÔ∏è

```
          VMX root   (hypervisor)   ‚Üê new privilege layer
Ring 0 ‚ïê‚ïê‚ïê guest kernel (CPL=0 inside VM)
Ring 3 ‚ïê‚ïê‚ïê guest user
```

- VT-x adds VM-exit/entry,¬†`VMREAD/VMWRITE`, EPT for 2-level paging.
    
- Rings 1-2 largely unused today; some OS-friendly ‚Äúpara-virt‚Äù drivers may opt-in for Ring 1 for low-latency hypercalls.
    

---

## 10 Key Take-aways & Further Reading üìö

1. **Timer tick**¬†guarantees OS pre-emption; modern kernels strive for¬†_tickless idle_¬†to save power.
    
2. x86 backward-compat forced creative register naming (AX ‚Üí EAX ‚Üí RAX).
    
3. Privilege separation is enforced via¬†**rings**,¬†**CPL**, and privileged¬†**instructions**¬†touching control registers.
    
4. The x87 FPU uses an 80-bit¬†_stack_¬†for historical and code-density reasons; SSE/AVX abandoned this model.
    
5. Linux keeps ISR ‚Äútop-halves‚Äù tiny to reduce cache pollution; most work deferred to softirq/thread context.
    

### Recommended code spelunking

```bash
# Inspect timer handler path (x86_64, v6.8)
cscope -R arch/x86/kernel/time.c
cscope -d include/linux/interrupt.h  # request_irq()

# Examine syscall entry trampolines
objdump -d vmlinux | grep -A4 'syscall_entry'
```

### Papers / Documentation

- Intel¬Æ 64 and IA-32 Architectures SDM ‚Äì Vol 3, Ch 6 (Interrupt & Exception Ref.)
    
- Love, R.¬†**Linux Kernel Development**, Ch 10 (Timers and Timekeeping).
    
- McKenney, P. ‚Äú**Context-switch overheads in tickless kernels**‚Äù, LWN 2021.
    

---

> **Next steps**: deep-dive into x86 memory addressing modes and the ELF¬†_compile ‚Üí link ‚Üí load_¬†pipeline, as teased at lecture end.

```

*(Feel free to paste the Markdown into Obsidian; code blocks and diagrams render nicely. Let me know if you'd like SVG schematics or additional drill-downs on any subtopic!)*
```