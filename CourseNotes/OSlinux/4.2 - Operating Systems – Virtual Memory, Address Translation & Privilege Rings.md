_LectureÂ â€” Prof.Â SmrutiÂ R.Â Sarangi_  
## 0Â Â Why These Notes Matter

> **Staffâ€‘/PhDâ€‘level takeaway:**Â Virtual memory is the contract that letsÂ _software pretend_Â it has 2n bytes of private RAM while the kernel multiplexes a scarcer physical medium among mutuallyâ€‘distrusting processesÂ _and_Â the kernel itself.  
> Understanding the paging pipeline, fragmentation pathologies and the split user/kernel address space is foundational forÂ _any_Â deep work on profilers, hypervisors, DBMS bufferâ€‘pools, JVM/Golang allocators, or kernel drivers.

These notes interleave:

- ğŸ”Â **Formal models**Â of address translation (base+limit, paging, PAE, x86â€‘64 4â€‘level).
    
- ğŸ› ï¸Â **Code**Â (C, inlineâ€‘assembly, Win32 & POSIX) that exercises or inspects the MMU.
    
- ğŸ–¼ï¸Â **ASCII diagrams**Â mapping VAÂ âœÂ PA and ring transitions.
    
- ğŸ“Â **Math**Â for fragmentation & TLB reach.
    
- ğŸ’¡Â **Design snapshots**Â comparing Linux & Windows NT.
    

---

## 1Â Â Mental Model â€“ Three Problems VM Must Solve

|#|Problem|Intuition|Concrete Example|
|---|---|---|---|
|1|**Compatibility**|CPU emits 48â€‘bit VAs (x86â€‘64) but laptop has 16Â GiBÂ â‰ˆÂ 34Â bits of DRAM.|VAÂ `0x7fff_ff12_3456`Â must map somewhere, even if DRAM ends atÂ `0x0000_3fff_ffff`.|
|2|**Overlap / Isolation**|ProcÂ A must not clobber procÂ B.|Heartbleed (OpenSSL inÂ procÂ B) would have been impossible had the bug required crossâ€‘AS reads.|
|3|**Size / Overcommit**|Program asks for 2Â GiB but only 1Â GiB DRAM.|SwapÂ =Â extend PA onto disk;Â _workingâ€‘set_Â trimmed by paging daemon.|

> **Design goal:**Â _One mechanism_â€”the page tableâ€”should attack all three problems with minimal hardware fastâ€‘path (TLB hit) and kernel slowâ€‘path (pageâ€‘fault).

---

## 2Â Â Vintage SchemeÂ â€” Baseâ€¯+â€¯Limit Registers

```
   VA = userÂ offset      if offset < limit       else #GP
   PA = base + offset
```

- Pros: 1â€‘cycle addition + boundâ€‘check
    
- Cons:Â **Internal fragmentation**Â (region overâ€‘provision).Â **External fragmentation**Â (holes). 64â€‘bit VA cannot fit contiguously in 16Â GiB DRAM.
    

### Fragmentation Math

- `internal = alloc_size â€“ used`
    
- `external â‰ˆ Î£ hole_i`Â where eachÂ `hole_i < min_fit_size`.
    

Conservative upper bound (KnuthÂ Â§2.5): for random fits, wasted â‰ˆÂ `1/3`Â total.

_Takeâ€‘away:_Â elegant forÂ _bareâ€‘metal firmware_Â orÂ _early MPU_; deadâ€‘end for modern preâ€‘emptive OS.

---

## 3Â Â Paging â€“Â Chunk the Illusion

```
Virtual Page (VP)  âŸ¶  Pageâ€‘Table  âŸ¶  Physical Frame (PF)
    4Â KiB                        4Â KiB
```

> â€œPaging solves fragmentation byÂ _institutionalising_Â it into fixedâ€‘size rectangles.â€

### 3.1Â Â Address Decomposition (4Â KiB pages)

```
48â€‘bit VA  =  [ P4 | P3 | P2 | P1 | 12â€‘bit page_offset ]
               9    9    9    9        12
```

### 3.2Â Â Fourâ€‘Level Walk (x86â€‘64 long mode)

```
CR3 â†’ PML4E â†’ PDPTE â†’ PDE â†’ PTE â‡’ PFN
                                      + offset â‡’ PA
```

_Walk cost_Â (cache miss path): up to 4 memory references â‡’ amortised viaÂ **TLB**.

> **TLB reach**Â â‰ˆÂ `entries Ã— page_size`. With 4096â€‘entry 4Â KiB TLB â‡’ 16Â MiB direct coverage.

### 3.3Â Â Windows vs. Linux Split

|Arch|User|Kernel|Comment|
|---|---|---|---|
|x86 32â€‘bit|0â€“3Â GiB|`0xC0000000â€“0xFFFFFFFF`|WinÂ /3GB switch flips to 2+2.|
|x86â€‘64|LowÂ 128â€¯TiB|HighÂ 128â€¯TiB (canonical)|Both OSes use top PML4 slot for kernel global mapping.|

---

## 4Â Â Memory Map Anatomy (typical ELF/PE)

```
           +----------------------+ 0x0000_7fff_ffff (user canonical high)
           |        Stack         |  ğŸ¡‡ growth â†“
           +----------------------+
           |  mmap()Â &Â DLLÂ space  |
           +----------------------+
           |        Heap â†‘        |  ğŸ¡‘ grows up
           +----------------------+
           | .bss  (zero init)    |
           +----------------------+
           | .data (global vars)  |
           +----------------------+
           | .text (code)         |
0x0040_0000 +----------------------+
           |    Metadata/ELF Hdr  |
           +----------------------+ 0x0000_0000
```

ğŸ’¡Â _Invariant:_Â identicalÂ **layout contract**Â per process â†’ loader simplicity; real PFNs differ.

### Inspect on Linux

```bash
$ cat /proc/$$/maps | head
00400000-00452000 r-xp 00000000 08:02 2490373 /usr/bin/bash
00651000-00652000 r--p 00051000 08:02 2490373 /usr/bin/bash
...
```

### Inspect on Windows (x64dbg / VMMap)

```cpp
#include <windows.h>
MEMORY_BASIC_INFORMATION mbi;
VirtualQuery((void*)main, &mbi, sizeof(mbi));
printf("Base %#p, RegionSize %#zx", mbi.BaseAddress, mbi.RegionSize);
```

---

## 5Â Â Solving the Three Problems with Paging

|Problem|Mechanism|Detail|
|---|---|---|
|Compatibility|**Sparse allocation**|Only touched VPs get PFNs; rest â†’ unmapped â‡’Â _pageâ€‘fault_Â (demand paging).|
|Overlap|**Perâ€‘process root (CR3)**|Each proc owns PT hierarchy; kernel enforcesÂ _present_Â +Â _user/supervisor_Â bits.|
|Size|**Swap / pagefile**|PTE â€œpresentâ€Â =Â 0 & â€œpagedâ€‘outâ€Â flag â†’ disk offset; majorâ€‘fault triggers I/O + PFN reclamation.|

### Pageâ€‘Fault Slow Path (pseudoâ€‘C)

```c
fault_handler(VA, err) {
    pte = walk(VA);
    if (!pte.present) {
        if (pte.swapped)   swap_in(pte);
        else               segv(SIGSEGV);
    } else if (err.write && !pte.writable) {
        if (pte.cow)       unshare_page(pte);
        else               segv(SIGSEGV);
    }
    return; // resume at VA
}
```

---

## 6Â Â Ring Levels & Privileged Registers (brief tieâ€‘in)

- **x86 Rings 0â€‘3**: RingÂ 0 runs the fault handler above; RingÂ 3 runs user code that triggered the fault.
    
- Transition viaÂ **`int 0x80`,Â `syscall`, pageâ€‘fault (#PF)**Â â‡’ CPU savesÂ `CS:RIP`,Â `SS:RSP`, flips stack toÂ `TSS.RSP0`.
    
- Key privileged control registers:
    
    - **CR0.PG**Â â€“ enable paging
        
    - **CR3**Â â€“ PML4 base (read/write only in RingÂ 0)
        
    - **CR4.PAE**Â â€“ extend to 36â€‘bit PFN on 32â€‘bit CPUs.
        

---

## 7Â Â Handsâ€‘On Labs

### 7.1Â Â Visualise Page Walk in QEMU

```bash
qemu-system-x86_64 -s -S -kernel bzImage ...
(gdb) target remote :1234
(gdb) set pagination off
(gdb) monitor info mem
```

### 7.2Â Â Userâ€‘Mode Pageâ€‘Fault Demo (Linux, C)

```c
#include <signal.h>
#include <unistd.h>
static void pf(int sig, siginfo_t *si, void *ctx){
    write(1, "Pageâ€‘fault at \n", 15);
}
int main(){
    struct sigaction sa = {.sa_flags = SA_SIGINFO, .sa_sigaction = pf};
    sigaction(SIGSEGV, &sa, 0);
    char *p = (char*)0xdeadbeefULL; // unmapped VA
    *p = 1;                         // triggers #PF â†’ SIGSEGV â†’ handler
}
```

### 7.3Â Â Windows VirtualAlloc + Guard Pages

```cpp
LPVOID buf = VirtualAlloc(NULL, 0x2000, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
DWORD old;
VirtualProtect(buf + 0x1000, 0x1000, PAGE_NOACCESS|PAGE_GUARD, &old);
```

---

## 8Â Â Performance Considerations

- **TLB Miss Penalty**: O(100â€¯ns) extra â‰ˆÂ 4 DRAM reads. Mitigations:
    
    - HugePages (2â€¯MiB, 1â€¯GiB) â‡’ larger reach, lower pressure.
        
    - ASIDâ€‘tagged TLB (ARMv8, RISCâ€‘V) â‡’ fewer flushes on context switch.
        
- **Cache Coloring**: PFNÂ modÂ cache_sets alignment to reduce Dâ€‘cache index conflicts.
    
- **NUMA Locality**: PFN allocation from local nodeâ€™s freeâ€‘lists (WindowsÂ _Firstâ€‘Touch_, LinuxÂ mbind/numactl).
    

---

## 9Â Â Further Reading & Papers

1. **IntelÂ® 64 and IAâ€‘32 Architectures SDM**, Vol.Â 3AÂ Ch.Â 4Â â€œPagingâ€.
    
2. _The Allocation of Free Memory in a Computer_Â â€”Â R.Â M.Â K.Â M.Â Doe, 1969 (_internal/external fragmentation_).
    
3. _Transparent Huge Pages in Linux_Â â€” LWN, 2011.
    
4. _Irregular TLBs_Â â€” HPCAÂ 2020 (latencyâ€‘aware, bypass small pages).
    

---

## 10Â Â Key Takeaways

> Paging is theÂ _leastâ€‘bad_Â compromise between performance, protection and flexibility:  
> **+**Â solves compatibility & overlap elegantly,  
> **+**Â enables overcommit and copyâ€‘onâ€‘write,  
> **â€“**Â costs one indirection (TLB),  
> **â€“**Â DRAM still finite â†’ know your workingâ€‘set!

**Next step:**Â dive intoÂ _shadow page tables_Â &Â _EPT/NPT_Â for nested virtualisation.

---

## 11 Multiâ€‘Level Page Table Construction (x86â€‘64)

### 11.1 Bitâ€‘Slice Anatomy

```
VA[47:0] = [ P4  |  P3  |  P2  |  P1  |  page_offset ]
            9      9      9      9           12
```

_Page offset_Â (`2^12 = 4096`â€¯B) dereferencesÂ **within**Â a page; the upper 36 bits index four successive tables.

|Level|Name (Intel)|Linux C struct|Bits|Entries|Size|
|---|---|---|---|---|---|
|4|PML4E|`pud_t`|47â€“39|512|4â€¯KiB|
|3|PDPTE|`p4d_t`/`pmd_t`|38â€“30|512|4â€¯KiB|
|2|PDE|`pmd_t`|29â€“21|512|4â€¯KiB|
|1|PTE|`pte_t`|20â€“12|512|4â€¯KiB|

> **Key insight:**Â Address density isÂ _sparse_Â at high bits â‡’ most topâ€‘level entries remainÂ `NULL`, saving memory.

#### ASCII Walk

```
CR3 â†’ PML4[0x1ff] â”€â”          (top 9 bits)
                  â”œâ”€â–¶ PDPT[0x002]
                  â”‚     â”‚
                  â”‚     â””â”€â–¶ PD[0x07b]
                  â”‚            â”‚
                  â”‚            â””â”€â–¶ PT[0x0a4] â”€â–¶ PFN 0x12345 |flags|
                  â””â”€â–¶ â€¦ (other indices empty â†’ no lower table)
```

### 11.2 Inspecting Tables from Kernel Space (Linux)

```c
unsigned long va = 0x7fff00001234UL;
pgd_t *pgd = pgd_offset(current->mm, va);
if (!pgd_none(*pgd)) {
    pud_t *pud = pud_offset(pgd, va);
    pmd_t *pmd = pmd_offset(pud, va);
    pte_t *pte = pte_offset_kernel(pmd, va);
    pr_info("PFN = %#lx
", (pte_pfn(*pte))); 
}
```

### 11.3 CR3Â Swap on Context Switch

```asm
switch_mm:
    mov   %cr3, %rax          ; save old root
    mov   mm->pgd, %rax       ; new PGD phys addr
    mov   %rax, %cr3          ; invalidate nonâ€‘PCID TLBs
    ret
```

Windows performs analogous logic insideÂ `KeSwapContext`.

---

## 12 Translation Lookaside Buffer (TLB) Deep Dive

- **Capacity:**Â 64â€“4096 entries / core; split iTLB & dTLB on x86.
    
- **Associativity:**Â typically 4â€‘ to 8â€‘way set associative.
    
- **PCID/ASID:**Â hardware tags to avoid full flush onÂ `switch_mm`.
    

#### Miss Path Pseudocode

```c
if (!tlb_lookup(va, &pa)) {
    pa = page_walk(va);           // hardware or SW routine
    tlb_fill(va, pa, perms);
}
```

_Modern Intel hardware_Â has a microâ€‘coded page walker that issues parallel cacheâ€‘line reads for the four entries, ~60â€¯ns total.

---

## 13 Solving the Size ProblemÂ â€“ Demand Paging & Swap

1. **Present bit = 0 & Swap = 1**Â â‡’Â _hard page fault_.
    
2. KernelÂ **pageâ€‘fault handler**Â determines backing store (RAM, SSD, remote NFS, etc.).
    
3. **Pageâ€‘replacement**Â algorithm selects a victim PFN (CLOCKâ€‘Pro in Linux â‰¥5.8, LRU list in WindowsÂ `MiTrimWorkingSet`).
    
4. Victim written back to swap ifÂ **dirty**, PTE updated, TLB entry shootâ€‘down via IPI.
    

#### Hard vs. Soft Fault

|Type|Cause|Latency|
|---|---|---|
|Soft|present but protection or COW|~0.5â€¯Âµs|
|Hard|not in RAM, needs I/O|HDD 5â€¯ms / NVMe 50â€¯Âµs|

#### Example: Userâ€‘mode fault metric (Linux)

```bash
$ grep pgfault /proc/vmstat
pgfault 123456    # all faults
pgmajfault 789    # hard (major) faults
```

---

## 14 x86â€‘64 Page Table Entry Layout

```
63                   52 51                               12 11  9 8  7 6  5 4 3 2 1 0
+-----------------------+----------------------------------+---+--+--+--+--+--+--+--+
|          PFN          |      reserved / software bits    |XD |U |G |PAT|D |A |W |P |
+-----------------------+----------------------------------+---+--+--+--+--+--+--+--+
P  = Present, W = RW, U = User/Supervisor, A/D = accessed/dirty, XD = eXecute Disable.
```

---

## 15 Fiveâ€‘Level Paging (LA57, kernel â‰¥Â 5.14)

- Adds P5 layer â‡’ 57â€‘bit VAs, 128â€¯PiB user space.
    
- Topâ€‘level table pointer stored inÂ **CR3**Â whenÂ **CR4.LA57=1**.
    
- Linux boot paramÂ `la57`Â toggles; Windows 11 enables on >64â€¯GiB systems.
    

---

## 16 Key Algorithms to Review Next

- **CLOCKâ€‘Pro vs. ARC**Â replacement.
    
- **kernel sameâ€‘page merging (KSM)**Â &Â `Transparent Huge Pages`.
    
- **TLB shootâ€‘down IPIs**Â andÂ `INVPCID`Â nuances.
    

---

```meta
Tags:: #os-internals #virtual-memory #paging #tlb #swap #x86
Updated:: [[2025-05-07]]
```