https://juejin.cn/post/7258509816691245093
https://juejin.cn/post/7258670269924081723
## Introduction

### Overview
- **Topic**: Time Wheel Algorithm
- **Context**: Data Structures and Algorithms
- **Purpose**: Efficient scheduling of time-based events, crucial in fields like computer networks, operating systems, and distributed systems.

## Conceptual Foundation of Time Wheel

- **Design Principle**: Divides time into fixed intervals, creating a circular structure with slots for event lists. It operates on a tick mechanism, executing events in the current slot based on the time pointer's position.

![Time Wheel Illustration](image.png)

## Advantages and Limitations

### Advantages
- **Batch Task Efficiency**: Optimizes thread resources for scheduling tasks, managing them through the time wheel for efficient execution.
- **Complexity Reduction**: Offers O(1) complexity for insertions and deletions, surpassing traditional scheduling mechanisms like Javaâ€™s `java.util.Timer` and `DelayedQueue`.

### Limitations
- **Accuracy Concerns**: The granularity of time units might not suit tasks requiring high precision.
- **Downtime Recovery Challenges**: In-memory storage of the task queue impedes automatic rescheduling post-crashes.

## Implementation in Dubbo

### Core Framework
- **Package**: Located within `org.apache.dubbo.common.timer` of the `dubbo-common` module.
- **Interfaces**:
  - **Timer**: Basic timer functionality.
  - **Timeout**: Manages timeout operations, generated by `newTimeout`.
  - **TimerTask**: Represents individual tasks, directly associated with `Timeout` instances.

### Critical Components

- **HashedWheelTimeout**: Implements `Timeout`, acting both as a doubly linked list node within a time slot and as a task handle for external manipulation.
- **HashedWheelBucket**: Denotes a time wheel slot, managing tasks as a doubly linked list of `HashedWheelTimeout` objects.
- **HashedWheelTimer**: Core time wheel implementation, orchestrating task scheduling and execution.

## Technical Details

### HashedWheelTimeout
- **Roles**: Doubly linked list node and task handle.
- **States**: Includes initial, cancelled, and expired states with atomic state updates.

### HashedWheelBucket
- **Function**: Manages a slot in the time wheel.
- **Structure**: Uses `head` and `tail` to manage a doubly linked list of tasks.

### HashedWheelTimer
- **Implementation Highlights**:
  - **Tick Duration**: Specifies the time each tick represents, setting the scheduling granularity.
  - **Wheel Structure**: An array forming the circular queue with slots (`HashedWheelBucket`) for tasks.
  - **Worker Thread**: Executes scheduled tasks, ensuring only one instance per task at any time.

## Usage Scenarios in Dubbo

### Failed Retries
- **Application**: Automates retry mechanisms for tasks like provider registration or consumer subscription failures.

### Periodic Tasks
- **Usage**: Supports regular operations such as sending heartbeat signals, handling timeouts, and managing reconnections after network failures.

## Enhanced Summary

- **Dubbo's Simplification**: Adopts a straightforward approach to task scheduling without addressing long-duration timing or restart recovery.
- **Technical Optimization**: Implements `remainingRounds` for tasks, reducing execution rounds per wheel turn to enhance efficiency.
- **Execution Thread Concerns**: Notes potential impacts on task execution accuracy due to delays from processing large batches of tasks.

## Conclusion

The Time Wheel algorithm, particularly as applied in Dubbo, showcases a streamlined yet powerful method for time-based task scheduling. By offering detailed technical insights into its operation, software engineers gain a robust tool for efficient event management within complex systems.

---
# Detailed Obsidian Notes on Time Wheel Algorithm (Part 2) for Software Engineers

## Introduction

This document extends the discussion on the Time Wheel Algorithm, focusing on its implementation in Netty, application scenarios, and a detailed look into Kafka and Qunar's QMQ implementation. The Time Wheel Algorithm is pivotal for scheduling time-based events, particularly in networking and distributed systems.

## Time Wheel in Netty

Netty's time wheel implementation serves as the foundation for Dubbo's version. The key components remain consistent:

- **HashedWheelTimer**: The main class implementing the time wheel.
- **HashedWheelBucket**: Represents a slot in the wheel holding scheduled tasks.
- **HashedWheelTimeout**: Encapsulates individual tasks within the wheel slots.
- **Worker**: A dedicated thread for advancing the time wheel and executing tasks.

## Application Scenarios

The Time Wheel Algorithm excels in scenarios requiring precise timing control, including:

- **Delayed Message Dispatch**: Scheduling messages to be sent after a specified delay.
- **Heartbeat Detection**: Regularly sending heartbeat messages to maintain a live connection.
- **Connection Timeout Detection**: Monitoring client connections for inactivity or timeout.
- **Reconnection Strategies**: Managing intervals between connection attempts after disconnections.
- **Rate Limiting**: Controlling the frequency of certain actions to prevent system overload.

## Kafka's Time Wheel Implementation

Kafka employs the Time Wheel Algorithm for various delayed operations such as message production, fetching, and deletion. The core concepts include:

- **TimingWheel**: A circular queue implemented as an array, with each element potentially holding a list of scheduled tasks (`TimerTaskList`).
- **TimerTaskList**: A circular doubly linked list representing scheduled tasks.
- **TimerTaskEntry**: Items within the `TimerTaskList`, each representing a scheduled task (`TimerTask`).

### Hierarchical Time Wheels

For tasks exceeding the current wheel's time span, Kafka utilizes a hierarchical approach, placing the task in a higher-level wheel with a larger span. This method allows handling long-duration tasks more efficiently.

## Qunar's QMQ Implementation

QMQ, unlike RocketMQ's fixed-delay levels, offers scheduled messages with flexible timing up to two years. It utilizes a two-layer hash wheel for this purpose:

- **Message Log**: Stores incoming messages as a write-ahead log (WAL).
- **Schedule Log**: Organized by delivery time, with each hour mapped to a separate file. It's the first layer of the hash wheel, located on the disk.
- **Dispatch Log**: Records successful message deliveries, excluding message content. It helps in determining delivered messages after restarts.

### Core Implementation Highlights

- **Dual-layer Hash Wheel**: Comprises a disk-based layer for broad time spans and an in-memory layer for precise scheduling.
- **Delayed Operation Reaper**: A dedicated thread in Kafka for harvesting expired operations from the `DelayQueue`, advancing the time wheel.

## Summary for Software Engineers

The Time Wheel Algorithm's efficiency and precision make it indispensable for managing time-based events in distributed systems. While Netty lays the groundwork, Kafka and Qunar's QMQ expand upon it to address more complex scheduling needs, such as hierarchical time wheels and flexible delay intervals. Understanding these implementations provides valuable insights into handling scheduled tasks in high-throughput environments.