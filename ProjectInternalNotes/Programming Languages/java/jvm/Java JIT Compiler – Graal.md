## 1. Overview

This deep dive explores **Graal**, the new **Just-In-Time (JIT) compiler** for Java, focusing on its advantages, architecture, and functionality. Graal, developed as part of the **GraalVM project** by Oracle, introduces significant improvements over the traditional **HotSpot JIT compilers**, providing better performance, memory safety, and debugging capabilities. 

We will also cover **tiered compilation**, JVMCI (JVM Compiler Interface), Graal’s **data structures**, and its usage in **Ahead-of-Time (AOT) compilation**.

---

## 2. What Is a JIT Compiler?

A **JIT compiler** converts **Java bytecode** (generated by `javac`) into **machine code** that the CPU can execute.

- **Bytecode** is a compact representation of the source code.
- The **JVM** starts by interpreting the bytecode, which is slower than executing native machine code.
- The JIT compiler optimizes frequently used methods by compiling them into machine code for better performance.

### Key Concepts
- **javac**: Compiles Java source code into JVM bytecode.
- **Interpreter**: Executes bytecode directly but with slower performance.
- **JIT Compiler**: Converts bytecode to machine code just before execution, improving performance dynamically.

---

## 3. Detailed Look into the JIT Compiler

The **HotSpot VM** contains two traditional JIT compilers:
1. **C1 (Client Compiler)**: Produces less optimized code but compiles quickly. Ideal for desktop applications.
2. **C2 (Server Compiler)**: Produces highly optimized code but takes longer. Suitable for server applications.

### 3.1. Tiered Compilation

Java uses both **C1** and **C2** compilers through **tiered compilation**:
- Methods start in **interpreted mode**.
- **C1** compiles frequently called methods quickly.
- If the method's usage increases, it is recompiled by **C2** for better optimization.

This method allows Java to balance between **fast startup** and **optimized long-running performance**.

### 3.2. The Server Compiler (C2)

- **C2** is highly optimized and can produce machine code faster than some C++ code.
- Written in **C++**, but it's difficult to maintain and prone to segmentation faults.
- No major updates for years, making it a limiting factor in future improvements.

---

## 4. Project GraalVM

**GraalVM** is a project by Oracle that provides a new **JIT compiler** as part of the **Graal** ecosystem. It supports multiple languages (Java, JavaScript, Python, R, Ruby, etc.) and aims to provide **polyglot** programming capabilities.

### 4.1. Graal: A JIT Compiler in Java

- **Graal** is written entirely in **Java**, offering:
  - **Memory safety**: Avoids crashes common in C++ compilers.
  - **Debugging**: Easier to debug with modern Java tooling.
  - **Faster evolution**: Independent from HotSpot’s C2 architecture.
  
To enable **Graal** in Java:
```bash
-XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler
```

This allows execution with the **Graal JIT compiler**, providing improved performance, memory management, and compilation speed.

### 4.2. JVM Compiler Interface (JVMCI)

**JVMCI** allows **Graal** to interact with the JVM, replacing the standard tiered compilation approach. It provides a clean interface between the JVM and the JIT compiler:

```java
interface JVMCICompiler {
    byte[] compileMethod(byte[] bytecode);
}
```

- **JVMCI** is part of **OpenJDK** since **JDK 9**.
- Graal interacts with the JVM via **CompilationRequest**, allowing access to method profiling data and other metrics.

---

## 4.3. Graal in Action

Let’s explore **Graal’s performance** through an example program, `CountUppercase.java`:

```java
public class CountUppercase {
    static final int ITERATIONS = Math.max(Integer.getInteger("iterations", 1), 1);

    public static void main(String[] args) {
        String sentence = String.join(" ", args);
        for (int iter = 0; iter < ITERATIONS; iter++) {
            if (ITERATIONS != 1) {
                System.out.println("-- iteration " + (iter + 1) + " --");
            }
            long total = 0, start = System.currentTimeMillis(), last = start;
            for (int i = 1; i < 10_000_000; i++) {
                total += sentence.chars().filter(Character::isUpperCase).count();
                if (i % 1_000_000 == 0) {
                    long now = System.currentTimeMillis();
                    System.out.printf("%d (%d ms)%n", i / 1_000_000, now - last);
                    last = now;
                }
            }
            System.out.printf("total: %d (%d ms)%n", total, System.currentTimeMillis() - start);
        }
    }
}
```

To run this using **Graal**:
```bash
javac CountUppercase.java
java -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:+UseJVMCICompiler
```

### Sample Output:
```plaintext
1 (1581 ms)
2 (480 ms)
3 (364 ms)
4 (231 ms)
...
total: 59999994 (3436 ms)
```

As seen, the **initial execution time** is longer due to **JIT warm-up**, but performance improves as methods are compiled and optimized.

---

### 4.4. Comparing Graal with C2

Running the same program with **C2** (disabling Graal):
```bash
java -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler
```

Sample Output:
```plaintext
1 (510 ms)
2 (375 ms)
3 (365 ms)
...
total: 59999994 (4004 ms)
```

Here, the **initial warm-up time** is shorter, but Graal generally provides more significant performance improvements over longer execution.

---

## 4.5. Graal’s Data Structures

### Program Dependence Graph (PDG)

Graal compiles code by representing it as a **Program Dependence Graph (PDG)**:
- **Data Nodes**: Represent operations like loading or arithmetic.
- **Control Nodes**: Manage the order of execution.

#### Example: Simple Addition
```java
int x = 1;
int y = 2;
int result = x + y;
```

This would create the following **PDG**:
```plaintext
[x] --> [Load x]      <-- Data Flow
[y] --> [Load y]      <-- Data Flow
         [Add]
```

### Loop Example

Consider a more complex example with a **loop**:
```java
int sum = 0;
for (int i = 0; i < values.length; i++) {
    sum += values[i];
}
```

**Graph Representation**:
```plaintext
[Begin Loop] <-- Control Flow
    [Load i]  [Load values[i]]
    [Add] <-- Data Flow
[End Loop]
```
![[Screenshot 2024-09-23 at 4.44.50 PM.png]]
This introduces both **data flow** and **control flow** edges. Graal’s **graph-based structure** makes it well-suited to optimize control-heavy code, such as loops.

### Visualizing the Graph
Graal graphs can be visualized using the **IdealGraphVisualizer (IGV)**:
```bash
mx igv
```

To enable dumping of Graal graphs:
```bash
-Dgraal.Dump=true
```

---

## 4.6. Ahead-of-Time (AOT) Compilation

In addition to JIT, Graal also supports **Ahead-of-Time (AOT) Compilation** via **JEP 295**.

- **AOT Compilation** compiles **all methods offline**, without requiring them to be invoked first.
- AOT can help improve **startup times** for applications where JIT would otherwise introduce delays.

---

## 5. Conclusion

Graal represents a major step forward for **Java JIT compilation**, offering:
- **Improved performance** over traditional HotSpot compilers.
- **Memory safety** and easier maintenance, thanks to its Java-based implementation.
- The ability to integrate with existing **HotSpot** VMs via the **JVM Compiler Interface (JVMCI)**.
  
Additionally, **graph-based optimization** and **Ahead-of-Time compilation** make Graal a highly versatile tool for optimizing complex applications.

For further exploration, Graal’s source code and configuration options are available on **GitHub**.