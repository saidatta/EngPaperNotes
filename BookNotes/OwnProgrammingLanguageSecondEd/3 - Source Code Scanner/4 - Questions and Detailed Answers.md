### 1. Regular Expression for Dates

**Question:**  
Write a regular expression to match dates in `dd/mm/yyyy` format. Is it possible to write this regular expression so that it only allows legal dates?

**Discussion:**  
A common format for dates is `dd/mm/yyyy`, where:
- `dd` = 01–31
- `mm` = 01–12
- `yyyy` = four-digit year (e.g., 2024)

**A Basic Regex (Not Fully Validating):**

```regex
^[0-3][0-9]/[0-1][0-9]/[0-9]{4}$
```

**Explanation:**
- `[0-3][0-9]` matches any day from `00` to `39` (too broad!).
- `[0-1][0-9]` matches any month from `00` to `19` (also too broad).
- `[0-9]{4}` matches a 4-digit year.

This regex syntactically matches something like `31/09/2024`, which might be allowed by the regex but `09` is a valid month. A better month pattern would be `(0[1-9]|1[0-2])`, ensuring months 01–12. For days, `(0[1-9]|[12][0-9]|3[01])` ensures days 01–31. But remember, not all months have 31 days.

**Improved Regex:**
```regex
^(0[1-9]|[12][0-9]|3[01])/(0[1-9]|1[0-2])/[0-9]{4}$
```

This disallows impossible values like `00/00/0000` or `32/13/2024`. However, it still allows `31/04/2024` (April 31 does not exist).

**Can We Validate Real Calendar Dates With Just Regex?**  
Pure regex is not Turing-complete and cannot easily handle all calendar rules (like leap years and month lengths) in a simple pattern. Complex regex patterns might partially validate dates, but fully ensuring all legal dates (e.g., `29/02/2024` is valid but `29/02/2023` is not) is extremely difficult and generally not practical. Usually, you would parse the string after matching the format and do a semantic check in code.

**Conclusion:**  
While we can restrict the format and rule out obviously invalid dates (like `99/99/9999`), fully enforcing all calendar rules with a single regex is either impossible or extremely convoluted. Most real-world solutions match a general pattern and then rely on further validation in code.

---

### 2. Difference Between yylex() Return Value, yytext, and yylval

**Question:**  
Explain the difference between the return value that `yylex()` returns to the caller, the lexeme that `yylex()` leaves in `yytext`, and the token value that `yylex()` leaves in `yylval`.

**Key Concepts:**
- `yylex()` is the scanner function generated by tools like Flex/JFlex/UFlex.
- `yytext` is a global variable (or method in OOP-style) holding the *current lexeme’s text*.
- `yylval` is a global variable (often a union or a data structure) where `yylex()` can store additional information about the token.

**Differences:**
1. **yylex() return value:**  
   - An **integer category code** representing the type of token found.
   - Example: `IF_KEYWORD`, `IDENTIFIER`, `INTLIT` might be represented by unique integers.
   - The parser (e.g., generated by Yacc/Bison/iyacc) uses this integer to decide how to proceed in the grammar.

2. **yytext:**  
   - A **string** containing the exact lexeme matched by the scanner.
   - Example: If the token is `123`, `yytext` = `"123"`.
   - Useful for extracting literal values, names, etc.

3. **yylval:**  
   - A **data structure** (often a global variable) where the scanner can place additional token attributes.
   - Can hold typed values: integers for `INTLIT`, strings for `STRINGLIT`, and so on.
   - The parser uses this to get semantic information about the token, not just its category.

**Conclusion:**  
- `yylex()` returns a simple integer code for the parser.
- `yytext` holds the raw matched text of the current token.
- `yylval` is where the scanner can store a richer, semantically meaningful representation of that token (like a `token` object or structured data).

---

### 3. If a Regex Doesn’t Return a Value, What Happens?

**Question:**  
Not all `yylex()` regular expressions return an integer category after they match. When a regular expression does not return a value, what happens?

**Explanation:**
- Some tokens, like whitespace or comments, are matched by regular expressions but produce **no return value**.
- In these cases, the scanner simply consumes the matched characters and continues scanning the input without producing a token for the parser.
- Essentially, `yylex()` keeps reading input until it finds a lexeme that returns a token category.

**ASCII Visualization:**
```ascii
Input: "   if (x < 10)"
Regex for whitespace matches "   "
No return --> Scanner advances
Next regex matches "if" 
Return token IF_KEYWORD
```

**Result:**  
The parser never sees tokens for whitespace or comments. They are effectively invisible, acting as separators.

---

### 4. Flex’s Tie-Breaking Rules for Ambiguous Matches

**Question:**  
Lexical analysis must handle ambiguity. What if multiple regular expressions can match at the same position? Describe Flex’s tie-breaking rules.

**Flex Tie-Breaking Rules:**

1. **Longest Match Wins:**  
   Flex tries all regular expressions and finds those that can match at the current input position. It chooses the one that consumes the *most characters* from the input.

   ```ascii
   Input: "identifier"
   RE1: [a-z]+ matches "identifier"
   RE2: [a-z]+[0-9]* matches "identifier"
   Both match full "identifier"
   Longest tie -> next rule
   ```

2. **Rule Order (First Listed Wins):**  
   If two or more patterns match the same maximal number of characters, Flex selects the first one that appears in the lex specification file.
   
   ```ascii
   %%  
   [a-z]+ { return IDENT; }        # Rule A
   [a-z]+  { return ANOTHERIDENT;} # Rule B

   Input: "abc"
   Both match 3 chars
   Rule A appears first -> chosen
   ```

**Conclusion:**  
Flex resolves ambiguities by first taking the longest possible match. If there is a tie in length, it picks the earliest defined rule in the lex file.

---

## Summary of Answers

1. **Date Regex:**  
   Basic pattern: `^(0[1-9]|[12][0-9]|3[01])/(0[1-9]|1[0-2])/[0-9]{4}$` ensures format, but fully legal date validation (e.g., leap years) is not practical with pure regex.

2. **Return value vs yytext vs yylval:**  
   - `yylex()` return: integer token code for the parser.  
   - `yytext`: raw lexeme string matched by the scanner.  
   - `yylval`: a structured value holding semantic attributes of the token.

3. **No Return Value Case:**  
   When a rule does not return a token, the scanner consumes the matched characters and continues scanning. Such matches (like whitespace) never produce tokens for the parser.

4. **Flex Tie-Breaking:**  
   Longest match rule first, then by order in the lex specification if there’s a tie in length.

---

**You now have clearer insights into regex complexities, token attributes, and tie-breaking rules in lexical analysis.**