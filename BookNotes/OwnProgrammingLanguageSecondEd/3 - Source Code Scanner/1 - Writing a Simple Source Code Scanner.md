Below is an example of deeply detailed Obsidian-style notes for experienced engineers. They incorporate code snippets, ASCII diagrams, and formatting techniques. The notes reflect the content of the shared snippet, explaining how to write and run a simple source code scanner using UFlex or JFlex, and integrate it into a main program (either in Unicon or Java).

**Context:**  
At this stage, we’re moving from theory into a practical demonstration. We’ll write a minimal scanner using a `*.l` lex specification that recognizes a few token types (names, numbers, whitespace) and handles errors. This will familiarize us with the toolchain and show how UFlex/JFlex integrate with Unicon/Java code.

---

### Goals

- Implement a simple scanner that:
  - Identifies **names** (alphabetic sequences)
  - Identifies **numbers** (digit sequences)
  - Ignores **whitespace**
  - Reports **errors** for unrecognized input

- Demonstrate how to:
  1. Write a lex specification (`.l` file).
  2. Generate a scanner using `uflex` or `jflex`.
  3. Integrate the scanner with a `main()` program in Unicon or Java.
  4. Run the scanner on a sample input.

---

### Lex Specification: `nnws.l`

This lex file works for both UFlex (Unicon) and JFlex (Java). The trick is to keep the semantic actions minimal and compatible with both languages.

**`nnws.l`:**

```lex
%%
%int
%%
[a-zA-Z]+  { return 1; }
[0-9]+     { return 2; }
[ \t\r\n]+ { /* skip whitespace */ }
.          { simple.lexErr("unrecognized character"); }
```

**Explanation:**

- `%%` separates sections. The first `%%` ends the (empty) JFlex import section; the second `%%` starts the rules section.
- `%int` tells JFlex to return integers instead of objects.
- `[a-zA-Z]+`: Matches a **name**. On a match, we `return 1;`.
- `[0-9]+`: Matches a **number**. On a match, we `return 2;`.
- `[ \t\r\n]+`: Matches whitespace, no return (ignored).
- `.`: Matches any other single character. On match, calls `simple.lexErr(...)`.

The variable `yytext` will hold the lexeme text matched by the current pattern.

**Note:** The `simple.lexErr` call indicates error handling. We'll define the `simple` class/object in Unicon or Java to provide this method.

---

### ASCII Illustration of Matching

```ascii
Input: "Dorrie is 1 fine puppy"

Matches:
Dorrie -> [a-zA-Z]+ -> token type 1
is     -> [a-zA-Z]+ -> token type 1
1      -> [0-9]+     -> token type 2
fine   -> [a-zA-Z]+ -> token type 1
puppy  -> [a-zA-Z]+ -> token type 1

Whitespace is skipped
Any other chars would trigger '.' and lexErr()
```

---

### Integrating with Unicon: `simple.icn`

**Key Points:**

- Unicon’s `main()` is outside any class.
- `yyin` sets the input file stream for the generated scanner.
- `yylex()` returns token types (integers 1 or 2) until EOF.
- On each token, print out `yytext` and its category.
- The `simple` class defines `lexErr()` which halts on errors.

**`simple.icn`:**

```unicon
procedure main(argv)
   simple := simple()        # Create an instance of 'simple'
   yyin := open(argv[1])     # Open the input file
   while i := yylex() do     # Call the scanner until EOF
      write(yytext, ": ", i)
end

class simple()
   method lexErr(s)
      stop(s, ": ", yytext)
   end
end
```

**Explanation:**

- `simple := simple()` constructs a single instance of `simple`.
- `while i := yylex() do` loops until `yylex()` returns null (EOF).
- For each token, print `yytext` and token ID.
- `lexErr` stops execution with an error message.

---

### Integrating with Java: `simple.java`

**Key Points:**

- Java `main()` is inside a class.
- Use `FileReader` to feed input to `Yylex` (the generated scanner class).
- `lex.yylex()` returns tokens until `YYEOF`.
- Use `simple.lexErr()` for errors, and `simple.yytext()` for current lexeme.
- The `yytext()` method in `simple.java` calls `lex.yytext()` to get the matched string.

**`simple.java`:**

```java
import java.io.FileReader;

public class simple {
   static Yylex lex;

   public static void main(String argv[]) throws Exception {
      lex = new Yylex(new FileReader(argv[0]));
      int i;
      while ((i = lex.yylex()) != Yylex.YYEOF) 
         System.out.println("token " + i + ": " + yytext());
   }

   public static String yytext() {
      return lex.yytext();
   }

   public static void lexErr(String s) {
      System.err.println(s + ": " + yytext());
      System.exit(1);
   }
}
```

**Explanation:**

- `Yylex` is generated by `jflex nnws.l`.
- `yytext()` static method returns `lex.yytext()`.
- If unrecognized input is found, `lexErr()` prints an error and exits.

---

### Building the Scanner

**Process Overview:**

1. Run `uflex` or `jflex` on `nnws.l` to generate a scanner source file (`nnws.icn` for Unicon, `Yylex.java` for Java).
2. Compile scanner and main program.
3. Run the resulting executable/class with the input file.

**ASCII Build Diagram:**

```ascii
          +-----------+          +--------------+
          |  nnws.l   |          |   simple.icn |
          +-----+-----+          +------+-------+
                |                   |
          uflex/jflex              unicon compile
                |                   |
                v                   v
          nnws.icn / Yylex.java    simple (executable)
                |                   
             (Linking)              
                |
                v
           final scanner
```

**For Java:**

```ascii
          nnws.l            simple.java
            |                  |
          jflex              javac
            |                  |
          Yylex.java  +-----  Yylex.class + simple.class
            |          (Run with Java)
            v
          java simple dorrie.in
```

---

### Example Run

**Input file:** `dorrie.in`

```
Dorrie is 1 fine puppy
```

**Running with Unicon:**

```bash
uflex nnws.l
unicon simple nnws
./simple dorrie.in
```

**Running with Java:**

```bash
jflex nnws.l
javac simple.java Yylex.java
java simple dorrie.in
```

**Expected Output:**

```
token 1: Dorrie
token 1: is
token 2: 1
token 1: fine
token 1: puppy
```

**Interpretation:**

- `1` means we got a name.
- `2` means we got a number.
- Whitespace is ignored.
- No errors encountered, so no lexErr() calls.

---

### Next Steps

- This basic setup provides a working scanner.
- Next, we’ll enhance it to handle more token types and integrate with a parser.
- Additional features might include storing line/column numbers, handling comments, and improving error messages.

---

**Recap:**

- We learned how to write a simple lex spec that recognizes names, numbers, and whitespace.
- We integrated the scanner with a Unicon main and a Java main.
- We compiled and ran the example, verifying the output.

**You are now ready to expand the scanner to handle more complex tokens and eventually integrate it into a full compiler pipeline.**

---

**Related Links:**

- [[Regular Expressions]]  
- [[UFlex and JFlex Documentation]]  
- [[Compiler Pipeline Overview]]  

---

> [!TIP]
> If you encounter errors, double-check that you haven’t introduced language-specific code in the lex specification. Keep the actions simple and host-language-agnostic if you want to reuse the same `.l` file for both Unicon and Java.

---

End of Notes.