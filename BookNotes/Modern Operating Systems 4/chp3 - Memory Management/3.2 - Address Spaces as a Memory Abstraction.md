#### Overview
- **Context**: Discusses address spaces as an essential abstraction in memory management, solving problems arising from direct exposure of physical memory to processes.
- **Key Point**: Address spaces provide each process with a private and independent set of memory addresses, enhancing security and efficiency.
#### Address Space Concept
1. **Problems with Direct Memory Access**:
   - Security risk with potential to disrupt the OS.
   - Difficulty in running multiple programs concurrently.
2. **Address Space Definition**: 
   - A set of addresses a process can use to address memory.
   - Similar to phone numbers or internet domains in concept.
   - Example: IPv4 addresses range from 0 to \(2^{32}-1\).
#### Base and Limit Registers
1. **Functionality**:
   - **Dynamic Relocation**: Mapping each process's address space to different physical memory parts.
   - **Hardware Implementation**: Two special registers - base and limit.
2. **Operation**:
   - **Base Register**: Holds the physical address where a program begins.
   - **Limit Register**: Contains the length of the program.
   - **Memory Reference**: Address generated by process + base value.
   - **Protection**: Checks if the generated address exceeds the limit value.
3. **Example**:
   - For a 16-KB program loaded at address 16,384, base = 16,384, limit = 32,768.
   - **Programming Example**:
     ```assembly
     JMP 28  ; In program, but hardware treats as JMP 16412.
     ```
#### Diagram Reference
- **Fig. 3-3**: Illustrates the settings of base and limit registers during program execution.
- ![[Screenshot 2023-11-14 at 3.05.18 PM.png]]
#### Code Snippet for Base and Limit Register Simulation (Hypothetical)
```python
def access_memory(address, base, limit):
    physical_address = address + base
    if physical_address >= limit:
        raise MemoryAccessFault("Access beyond limit")
    return physical_address
```
#### Advantages and Disadvantages
1. **Advantages**:
   - Provides private address spaces for processes.
   - Prevents unauthorized memory access.
2. **Disadvantages**:
   - Overhead of additional computation (addition and comparison) for every memory reference.
   - Requires specialized circuits for fast addition to minimize latency.
#### Historical Usage
- **CDC 6600**: Implemented base and limit registers with OS-level protection.
- **Intel 8088**: Lacked a limit register, offered multiple base registers for independent relocation of program text and data.
#### Comparisons & Equations
1. **Address Translation Equation**:
   - **Formula**: Physical Address = Process-Generated Address + Base.
   - **Example**: If base = 16,384 and process generates address 28, Physical Address = 16,384 + 28 = 16,412.
#### Further Exploration
- **Next Topics**: Exploring more advanced memory management schemes in modern CPU chips.
- **Related Concepts**:
  - Memory protection mechanisms.
  - Historical evolution of memory management in operating systems.
---
### 3.2.2 - Swapping in Memory Management
#### Overview
- **Context**: Discusses 'swapping' in memory management within operating systems, a key technique to handle memory overload.
- **Key Point**: Swapping is used when the cumulative memory requirement of all processes exceeds the available physical RAM.
#### Swapping Mechanism
1. **Definition**: Swapping involves bringing entire processes into memory, running them for a while, then storing them back on nonvolatile storage (like disk or SSD).
2. **Use Case**: Especially relevant when numerous processes (like background services in modern operating systems) consume significant memory.
3. **Example**: Windows applications checking for updates, requiring 5-10 MB each.
#### Swapping Process (Refer to Figure 3-4)
![[Screenshot 2023-11-14 at 3.06.49 PM.png]]
1. **Illustration**: Demonstrates how memory allocation changes as processes are swapped in and out.
2. **Process Sequence**:
   - Starting with a single process (A) in memory.
   - Swapping in additional processes (B, C, D) over time.
   - Swapping out processes as needed (e.g., A swapped out for D).
3. **Relocation Requirement**: Addresses in swapped processes need to be relocated upon re-entry into memory.
#### Memory Compaction
1. **Concept**: Combining multiple memory holes into one large hole by shifting processes.
2. **Limitation**: CPU-intensive and time-consuming, especially in large memory systems (e.g., 16-GB machine).
#### Memory Allocation Strategies
1. **Fixed Size Allocation**: Simple but inflexible, as it doesn't accommodate growth in process size.
2. **Dynamic Allocation**:
   - **Challenge**: Processes growing adjacent to other processes require moving or swapping to create space.
   - **Strategy**: Allocating extra memory for growth to minimize overhead.
   - **Efficiency**: Only swap the memory actually in use, not the extra allocated space.

#### Diagram Reference
- **Fig. 3-5**: Illustrates allocation of space for growing data segments in processes.
![[Screenshot 2023-11-14 at 3.07.14 PM.png]]
#### Code Snippet for Simulating a Simple Swapping Mechanism (Hypothetical)
```python
def swap_process(processes, swap_out, swap_in):
    processes.remove(swap_out)
    processes.add(swap_in)
    relocate_addresses(swap_in)
    return processes
```
#### Process Growth Management
1. **Stack and Data Segments**: 
   - **Configuration**: Stack at the top (growing downwards) and data segment near the program text (growing upwards).
   - **Handling Overflow**: Move to a larger hole, swap out, or terminate the process if no space is available.
#### Equations & Examples
1. **Memory Compaction Time Calculation** (Hypothetical):
   - **Formula**: Time = Memory Size / Copy Speed.
   - **Example**: For 16-GB memory with 8 bytes copied in 8 nsec, Time = \( \frac{16 \text{ GB}}{8 \text{ bytes/8 nsec}} \) = Approx. 16 seconds.
#### Further Exploration
- **Next Topics**: Virtual memory as an alternative strategy.
- **Related Concepts**:
  - Process management in operating systems.
  - Efficiency and performance implications of swapping.
---
#### 3.2.3 - Managing Free Memory in Operating Systems
- **Context**: This section covers strategies for managing free memory in operating systems, crucial for efficient and effective memory usage.
- **Key Point**: Dynamic memory assignment requires the OS to track and manage memory usage using various methods.
#### Memory Management Strategies
![[Screenshot 2023-11-14 at 3.07.59 PM.png]]
1. **Bitmaps**:
   - **Concept**: Memory divided into allocation units, each represented by a bit in a bitmap.
   - **Design Issue**: Allocation unit size affects the bitmap size and potential memory wastage.
   - **Operation**: `0` indicates a free unit, `1` indicates an occupied unit (or vice versa).
   - **Figure Reference**: See Figure 3-6 for a visual representation. 
   ![[Screenshot 2023-11-14 at 3.08.14 PM.png]]
1. **Linked Lists**:
   - **Structure**: A list of allocated and free memory segments, each entry detailing the segment type (hole or process), start address, length, and next item pointer.
   - **Advantages**: Easier to manage, especially when processes terminate or swap out.
   - **Linked List Types**: Single or double-linked, with double-linked lists being more convenient for finding previous entries.
#### Algorithms for Memory Allocation
1. **First Fit**:
   - **Description**: Allocates the first hole that is big enough.
   - **Performance**: Fast as it searches minimally.
2. **Next Fit**:
   - **Variation**: Similar to first fit but starts searching from the last found hole.
   - **Performance**: Slightly worse than first fit.
3. **Best Fit**:
   - **Operation**: Searches the entire list and selects the smallest adequate hole.
   - **Downsides**: Slower; results in more wasted memory due to tiny, unusable holes.
4. **Worst Fit**:
   - **Concept**: Chooses the largest available hole.
   - **Efficiency**: Not very effective, as simulation has shown.
5. **Quick Fit**:
   - **Method**: Maintains separate lists for common sizes requested.
   - **Advantage**: Extremely fast for finding a hole of the required size.
   - **Disadvantage**: Expensive to find neighbors for merging when processes terminate.
#### Code Snippet for a Simple First Fit Algorithm (Hypothetical)
```python
def first_fit(memory_list, process_size):
    for segment in memory_list:
        if segment.type == 'Hole' and segment.size >= process_size:
            allocate_memory(segment, process_size)
            return segment.start_address
    return None  # No suitable hole found
```
#### Memory Compaction and Fragmentation
- **Memory Compaction**: Combining smaller holes into a larger one, though CPU-intensive.
- **Fragmentation**: Result of allocation strategies leading to many small unusable holes.
#### List Maintenance
- **Process List vs. Hole List**: Maintaining separate lists for processes and holes can speed up allocation but complicates deallocation.
- **Optimization**: Storing hole information in the holes themselves, rather than separate structures.
#### Equations & Examples
1. **Bitmap Size Calculation**:
   - **Formula**: Bitmap Size = Memory Size / Allocation Unit Size.
   - **Example**: For a 32-bit memory with 4-byte allocation units, the bitmap size would be 8 bits.
#### Further Exploration
- **Related Topics**:
  - Specific memory allocators (buddy and slab) in Linux.
  - Resource tracking in file systems.
- **Next Steps**: Detailed study of virtual memory and other advanced memory management techniques.